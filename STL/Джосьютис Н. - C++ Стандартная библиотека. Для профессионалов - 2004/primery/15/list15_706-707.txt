namespace std {
    template <class T>
    class allocator {
      public:
        // Определения типов
        typedef size_t    size_type;
        typedef ptrdiff_t difference_type;
        typedef T*        pointer;
        typedef const T*  const pointer;
        typedef T&        reference;
        typedef const T&  const_reference;
        typedef T         value_type;

        // Привязка распределителя к типу U
        template <class U>
        struct rebind {
            typedef allocator<U> other;
        };

        // Функции возвращают адреса значений
        pointer       address(reference value) const;
        const_pointer address(const_reference value) const;

        // Конструкторы и деструктор
        allocator() throw();
        allocator(const allocator&) throw();
        template <class U>
          allocator(const allocator<U>&) throw();
        ~allocator() throw();

        // Функция возвращает максимальное количество элементов,
        // для которых может быть выделена память
        size_type max_size() const throw();

        // Выделение памяти для num элементов типа T без инициализации
        pointer allocate(size_type num,
                         allocator<void>::const_pointer hint=0);

        // Инициализация элементов выделенного блока p значением value
        void construct(pointer p, const T& value);
        // Удаление элементов инициализированного блока p
        void destroy(pointer p);

        // Освобождение блока p с удаленными элементами
        void deallocate(pointer p, size_type num);
    };
}


