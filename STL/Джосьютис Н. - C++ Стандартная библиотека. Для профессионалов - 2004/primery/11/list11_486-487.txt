// string/icstring.hpp
#ifndef ICSTRING_HPP
#define ICSTRING_HPP

#include <string>
#include <iostream>
#include <cctype>

/* Замена функций стандартного класса char_traits<char>
 * для того, чтобы операции со строками
 * выполнялись без учета регистра символов
 */
struct ignorecase_traits : public std::char_traits<char> {
    // Проверка равенства c1 и c2
    static bool eq(const char& c1, const char& c2) {
        return std::toupper(c1)==std::toupper(c2);
    }
    // Проверка условия "с1 меньше c2"
    static bool lt(const char& c1, const char& c2) {
        return std::toupper(c1)<std::toupper(c2);
    }
    // Сравнение до n символов s1 и s2
    static int compare(const char* s1, const char* s2,
                       std::size_t n) {
        for (std::size_t i=0; i<n; ++i) {
            if (!eq(s1[i],s2[i])) {
                return lt(s1[i],s2[i])?-1:1;
            }
        }
        return 0;
    }
    // Поиск c в s
    static const char* find(const char* s, std::size_t n,
                            const char& c) {
        for (std::size_t i=0; i<n; ++i) {
            if (eq(s[i],c)) {
                return &(s[i]);
            }
        }
        return 0;
    }
};

// Определение специального типа для таких строк
typedef std::basic_string<char,ignorecase_traits> icstring;

/* Определение оператора вывода,
 * так как тип трактовок отличен от типа,
 * заданного для std::ostream
 */
inline
std::ostream& operator << (std::ostream& strm, const icstring& s)
{
    // Простое преобразование icstring в обычную строку
    return strm << std::string(s.data(),s.length());
}

#endif    // ICSTRING_HPP


